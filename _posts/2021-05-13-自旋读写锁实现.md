---
layout: post
title:  "自旋读写锁实现"
subtitle: ""
description: "自旋读写锁实现"
date: 2021-05-13
author: "Sharp Liu"
categories: system program
---

{{ page.title }}

### 读写锁

读写锁是并发控制的一种同步机制，也称 "共享-互斥锁"、多读者-单写者锁。读操作可以并发重入，写操作是互斥的。

读写锁实现有多种方式，本文描述的是 **自旋读写锁** 的实现。


### 优先策略

读写锁的策略分为：

- 读操作优先：允许最大并发，但写操作可能饿死。
- 写操作优先：一旦所有已经开始的读操作完成，等待的写操作立即获得锁。
- 未指定优先级

本文实现的读写锁策略是 **写操作优先**


### 自旋读写锁的设计

采用 uint64_t（64位整形）类型作为锁内部值。

写操作占用 1 位最高位，其余位用于读操作。

写操作位用十六进制表示为 0x8000000000000000，每次只能有一个写锁操作。退出时重置写操作位。

读操作位支持多个并发读操作，最高支持 0x7FFFFFFFFFFFFFFF 个读操作。每发生一次读锁定操作，则增加 1，退出时减少 1。

**备注**：读写都使用 CAS 操作。


### 实现

自旋读写锁 C 语言实现

```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdbool.h>
#include <assert.h>


static const uint64_t SHARED_LOCK_INIT = 0;
static const uint64_t SHARED_WRITE_LOCKED = 1UL << 63;


typedef struct shared_rwlock_s    shared_rwlock_t;

struct shared_rwlock_s {
    uint64_t  lock;
};


void shared_lock_init(shared_rwlock_t *p)
{
    p->lock = SHARED_LOCK_INIT;
}


void shared_read_lock(shared_rwlock_t *p)
{
    uint64_t value;

    for ( ;; ) {
        value = p->lock;

        // is wirte locked?
        if (value >= SHARED_WRITE_LOCKED) {
            continue;
        }

        // increase reader bit.
        if (__sync_bool_compare_and_swap(&p->lock, value, value + 1)) {
            break;
        }
    }
}


void shared_read_unlock(shared_rwlock_t *p)
{
    assert(p->lock > SHARED_LOCK_INIT);

    __sync_sub_and_fetch(&p->lock, 1);
}


void shared_write_lock(shared_rwlock_t *p)
{
    uint64_t value;

    for ( ;; ) {
        value = p->lock;

        // is wirte locked?
        if (value >= SHARED_WRITE_LOCKED) {
            continue;
        }

        // set write lock bit.
        if (__sync_bool_compare_and_swap(&p->lock, value, value | SHARED_WRITE_LOCKED)) {
            break;
        }
    }

    // wait for active readers.
    while (p->lock != SHARED_WRITE_LOCKED) {
        ;
    }
}


void shared_write_unlock(shared_rwlock_t *p)
{
    assert(p->lock == SHARED_WRITE_LOCKED);

    __sync_sub_and_fetch(&p->lock, SHARED_WRITE_LOCKED);
}
```


### 附加功能

在锁内部增加一个循环等待上限值，当循环计数到达阈值时，仍然没有获得锁，让出当前 CPU 时间片。

伪代码

```c
count = 0;

for ( ;; ) {
    if (is_write_locked(&rwlock)) {
        if (++count >= limit_rate) {
            count = 0;
            sched_yield();
        }
    }
    ...
}
```



### 参考

[https://en.wikipedia.org/wiki/Readers%E2%80%93writer_lock](https://en.wikipedia.org/wiki/Readers%E2%80%93writer_lock)


